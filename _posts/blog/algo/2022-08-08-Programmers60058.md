---
layout: post
title: "[Algorithm] 프로그래머스(Programmers) - 괄호 변환 (60058)"
categories:
  - blog
  - algo
---

프로그래머스 - 괄호 변환 (60058)
{:.lead}
* this list will be replaced by the toc
{:toc .large-only}

## 프로그래머스 - 괄호 변환 (60058)

### 문제 핵심 
- 균형잡힌 괄호 문자열 : (의 개수와 )의 개수가 같을 때 
- 올바른 괄호 문자열 : 균형잡힌 괄호 문자열 + () 짝이 모두 맞을 경우
-------------
```
1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다. 
2. 문자열 w를 두 "균형잡힌 괄호 문자열" u, v로 분리합니다. 단, u는 "균형잡힌 괄호 문자열"로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다. 
3. 문자열 u가 "올바른 괄호 문자열" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 
  3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다. 
4. 문자열 u가 "올바른 괄호 문자열"이 아니라면 아래 과정을 수행합니다. 
  4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 
  4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. 
  4-3. ')'를 다시 붙입니다. 
  4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 
  4-5. 생성된 문자열을 반환합니다.
```

### 문제 접근 
- 위의 조건을 그대로 구현해주면 된다.

### 문제 후기 
- 위의 조건을 그대로 구현하면 되는 거라서 나름 쉽게 풀었던것 같다.

### 코드
```java
    static int[] dx = {0, 0, -1, 1};
    static int[] dy = {-1, 1, 0, 0};
    static int N; // board 크기
    static boolean[][] visited;
    static ArrayList<ArrayList<Point>> empty = new ArrayList<>(); // 게임보드 빈 공간
    static ArrayList<ArrayList<Point>> block = new ArrayList<>(); // 테이블 블록 저장

    public static int solution(int[][] game_board, int[][] table) {
        N = game_board.length;
        visited = new boolean[N][N];

        // 게임 보드 빈 공간
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (!visited[i][j] && game_board[i][j] == 0){
                    empty.add(check(game_board, i, j, 0));
                }
            }
        }

        // visited 초기화
        for (int i = 0; i < N; i++) {
            Arrays.fill(visited[i], false);
        }

        // 테이블 블록 체크
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (!visited[i][j] && table[i][j] == 1){
                    block.add(check(table, i, j, 1));
                }
            }
        }

        boolean[] visitedBoard = new boolean[empty.size()];
        int answer = 0;
        // 빈공간에 퍼즐을 맞춰 넣기
        for (int i = 0; i < block.size(); i++) {
            ArrayList<Point> blockCheck = block.get(i);

            for (int j = 0; j < empty.size(); j++) {
                ArrayList<Point> emptyCheck = empty.get(j);
                // 블럭 사이즈가 서로 맞고, 방문 하지 않은 블럭이라면
                if (emptyCheck.size() == blockCheck.size() && !visitedBoard[j]){
                    if (isRotate(emptyCheck, blockCheck)){ // 블럭이 들어갈 수 있는지 확인해본다.
                        answer += blockCheck.size();
                        visitedBoard[j] = true;
                        break;
                    }
                }
            }
        }

        return answer;
    }

    // 블럭 회전, 게임보드에 들어가는지 확인
    private static boolean isRotate(ArrayList<Point> empty, ArrayList<Point> block) {
        for (int i = 0; i < 4; i++) { // 90도 회전
            int zeroX = block.get(0).x;
            int zeroY = block.get(0).y;

            for (int j = 0; j < block.size(); j++) { // 회전 시키면서 좌표가 달라지기 대문에 0,0을 기준으로 블록 좌표 변경
                block.get(j).x -= zeroX;
                block.get(j).y -= zeroY; 
            }
            
            boolean isCollect = true;
            // 서로 좌표를 비교한다
            for (int j = 0; j < empty.size(); j++) {
                Point emptyPoint = empty.get(j);
                Point blockPoint = block.get(j);
                // 하나라도 안맞으면 멈추기
                if (emptyPoint.x != blockPoint.x || emptyPoint.y != blockPoint.y){
                    isCollect = false;
                    break;
                }
            }
            // 다 맞으면 블록 끼우기!
            if (isCollect)
                return true;
            else {
                // 90도 회전 : (x, y) -> (y, -x)
                for (int j = 0; j < block.size(); j++) {
                    int temp = block.get(j).x;

                    block.get(j).x = block.get(j).y;
                    block.get(j).y = -temp;
                }
                Collections.sort(block);
            }
        }
        return false;
    }

    public static ArrayList<Point> check(int[][] board, int x, int y, int type){
        Queue<Point> queue = new LinkedList<>();
        ArrayList<Point> points = new ArrayList<>();

        queue.add(new Point(x, y));
        visited[x][y] = true;
        // 블록이나 빈 공간의 기준점을 0,0으로
        points.add(new Point(0, 0));

        while (!queue.isEmpty()){
            Point cur = queue.poll();

            for (int i = 0; i < 4; i++) {
                int nx = cur.x + dx[i];
                int ny = cur.y + dy[i];

                if (nx < 0 || ny < 0 || nx >= N || ny >= N)
                    continue;

                if (visited[nx][ny] || board[nx][ny] != type)
                    continue;

                queue.add(new Point(nx, ny));
                visited[nx][ny] = true;

                points.add(new Point(nx - x, ny - y)); // 기준점이 0,0이기 때문에
            }
        }

        Collections.sort(points); // x를 기준으로 오름차순 정렬
        return points;
    }

    static class Point implements Comparable<Point>{
        int x;
        int y;
        public Point(int x, int y){
            this.x = x;
            this.y = y;
        }

        // 오름 차순 정렬
        @Override
        public int compareTo(Point o) {
            if (this.x == o.x)
                return this.y - o.y;
            return this.x - o.x;
        }
    }
```

### 시간 
![시간.png](/assets/img/data/60058.png)


