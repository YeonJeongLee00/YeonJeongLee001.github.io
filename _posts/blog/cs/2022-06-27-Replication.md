---
layout: post
title: "[DB] Replication"
categories:
  - blog
  - cs
---

데이터 베이스의 Replication에 대해 알아보자 📚
{:.lead}

<iframe width="100%" height="550" src="https://www.youtube.com/embed/95bnLnIxyWI" title="[10분 테코톡] ✌️ 영이의 Replication" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Replication 이란?

- 한 서버에서 다른 서버로 데이터를 동기화
- 원본 데이터를 가진 서버 - `소스 서버`
- 복제된 데이터를 가지는 서버 - `레플리카(Replica) 서버`

![그림1.png](/assets/img/data/img1.png){: width="70%"}

## 사용 이유?

### 스케일 아웃

- 부하를 줄이기 위해 사용
- 갑자기 늘어나는 트래픽을 대응하는데 유연한 구조
- 하나의 서버에서 감당하는 쿼리 처리를 두개, 세개 이상의 서버에서 나눠서 하니 부담이 줄어듬!

### 데이터 백업

- 레플리카를 안하더라도 백업을 해야한다
- 백업 과정은 실제 실행중인 쿼리들에 영향을 줄 수 있다
- 레플리카 서버에서 데이터 백업을 실행하여 소스 서버에서 백업시 발생하는 문제들을 해결

### 데이터 분석

- 분석용 쿼리를 대량의 데이터를 조회하고 쿼리 자체가 무거운 경우가 많다
  - 무거운 작업을 소스서버에서 하게 되면 실제 서비스에 문제가 될 수 있음
- 레플리카 서버에서 분석용 쿼리만 전용으로 하는 것이 좋다

### 데이터의 지리적 분산

- 데이터베이스와 애플리케이션 서버가 멀리 떨어져있다면 응답을 늦게 받게 된다
- 빠른 응답을 위해 애플리케이션 서버에 가깝게 서버를 구성하는 것이 좋다

## 사용 방법?

### 바이너리 로그

MySQL 서버에서 발생하는 모든 변경사항을 별도의 로그 파일에 순서대로 저장

- 데이터의 변경 내역
- 데이터베이스나 테이블의 구조 변경
- 계정이나 권한의 변경정보

```sql
show binary logs; # 바이너리 로그 파일 목록
show master status; # 파일명과 위치정보
```

![show binary logs;](./img/img3.png){: width="70%"}

![show master status;](./img/img2.png){: width="70%"}

> 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고
> 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤
> 자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버 간에 동기화가 이루어짐

→ 3개의 스레드에 의해 동작!

![그림2.png](./img/img4.png){: width="70%"}

### Binary Log Dump Thread

- Binary Log를 레플리카 서버로 전송하는 역할
  - 레플리카 서버가 소스 서버에 연결되면 소스서버 내부적으로 Binary Log Dump Thread를 생성

### Replication I/O Thread

- Binary Log Event를 가져와 로컬 서버의 파일(Relay Log)로 저장하는 역할
- 복제가 시작되면 스레드가 생성되고 복제가 멈추면 스레드는 종료

`Connection Metadata`

- 소스 서버에 연결할 때 사용하는 정보를 가지고 있다
- mysql.slave_master_info 테이블에 저장
- 버전에 따라 파일로 관리되는 경우도 있는데 파일로 관리되는 경우 MySQL 데이터 디렉토리에 파일 형태로 저장

`Relay Log`

- 가져온 바이너리 로그 이벤트를 레플리카 서버에 파일로 저장

### Replication SQL Thread

- Relay Log 파일의 이벤트들을 읽고 실행

`Applier Metadata`

- 어플라이어 : 릴레이 로그에 저장된 소스서버의 이벤트들을 서버에 적용하는 컴포넌트
- 이벤트가 저장된 릴레이로그 파일명과 파일내 위치정보를 담고 있으며 이 정보를 바탕으로 레플리카 서버에 이벤트들을 적용
- 소스서버에 연결할 때 사용하는 정보를 가지고 있다
- mysql.slave_relay_log_info 테이블에 저장

## 바이너리 로그 식별 방법?

> 기본적으로 MySQL 복제를 사용하려면 소스 서버에서 반드시 Binary Log가 활성화 돼 있어야 한다

→ `show master status` 사용

### 바이너리 로그 파일 위치 기반

- 레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서 위치로 바이너리 로그 이벤트를 식별해서 복제

```sql
# 소스 서버
bind-address=0.0.0.0
port=3306
log-bin=mysql-bin
**server-id=1**
```

```sql
# 레플리카 서버
bind-address=0.0.0.0
port=3306
**server-id=2**
replicate-do-db='seeyouthere'
```

- 이벤트 별로 이벤트가 최초로 발생한 MySQL 서버를 식별하기 위해 server_id가 이용
- server_id를 지정하지 않으면 기본 값이 1인데 replication을 하게 되면 레플리카 서버에서는 반드시 server_id를 지정해야함
- 레플리케이션에 참여하는 각 서버마다 다른 서버 id로 지정해야함

❌ **단점**

식별 과정이 소스 서버에서만 유효

동일한 이벤트가 레플리카 서버에서 동일한 위치와 동일한 파일명으로 저장된다는 보장이 없음

어떤 경우 동일한 이벤트인데 서로 다른 식별값을 가지는 경우가 있음

### 글로벌 트랜잭션 ID 기반(GTID)

MySQL 5.5버전 까지는 바이너리 로그 파일 기반 복제만 가능

- 복제에 참여한 서버들에서 고유하도록 각 이벤트에 부여된 식별값
- 소스 서버에서 발생한 각 이벤트들이 복제에 참여한 모든 서버들에서 동일한 고유 식별 값을 가지도록 한다

**⭕️ 장점**

- 장애가 발생해도 손쉽게 복제 토폴로지를 변경할 수 있다
- 장애 복구에 소요되는 시간도 줄어든다

## 바이너리 로그는 어떻게 생겼을까?

```sql
# 방식 변경
set global binlog_format = 'STATEMENT'
```

### Statement 방식

- SQL문을 바이너리 로그에 그대로 기록
- MySQL에 바이너리 로그가 처음 도입 됐을 때 부터 존재한 포맷

> 트랙잭션의 격리 수준이 반드시 `REPEATABLE-READ` 이상이어야 한다.  
> → 그 이하 방식에서는 하나의 트랙잭션 내에서도 각 쿼리가 실행되는 시점마다 SNAPSHOT이 달라질 수 있는데 이로 인해 복제시 서버와 레플리카 서버의 데이터가 일치하지 않을 수 있다

**⭕️ 장점**

손쉽게 SQL문들을 확인

**❌ 단점**

비 확정적(delete/update 에 order by 없이 limit 사용..)으로 처리될 수 있는 쿼리가 실행된 경우 statement 포맷에서는 복제 시 소스 서버와 레플리카 서버간 데이터가 달라질 수 있다.

### Row 방식

- 데이터 변경이 발생했을 때 변경된 값 자체가 바이너리 로그에 기록되는 방식

MySQL 5.7.7 버전 이후부터 바이너리 로그 기본 포맷

**⭕️ 장점**

어떤 형태의 쿼리든지 복제시 소스서버와 레플리카 서버의 데이터를 일관되게 한다

**❌ 단점**

많은 데이터를 변경하면 모든 데이터가 전부 기록되 바이너리 로그 파일이 단시간에 매우 커짐

어떤 쿼리들이 넘어왔고 현재 실행중인 쿼리가 어떤 것인지 레플리카 서버에서 확인할 수 없다

### Mixed 방식

- statement + row 방식
- `binlog_format = 'MIXED'` 로 지정하여 사용
- 쿼리의 대부분은 statement 포맷으로 기록될 가능성이 높은데, 만약 실행된 쿼리가 statement 포맷으로 기록되어 복제됐을 때 문제가 될 가능성이 있는 안전하지 못한 쿼리라면 Row 포맷으로 변환되어 기록!

## 복제 동기화 방식?

소스 서버가 레플리카 서버에 이벤트들이 잘 보내졌는지 확인하냐, 안하냐에 따라 복제 동기화 방식을 설정할 수 있다.

### 비동기 복제

![그림3.png](./img/img5.png){: width="70%"}

- 소스 서버가 레플리카 서버에서 변경 이벤트가 정상적으로 전달 됐는지 확인하지 않음
- 소스 서버는 레플리카 서버에 적용이 잘 됐는지 알지 못하게되고 소스 서버에 장애가 발생하면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 수 있다

### 반동기 복제

![그림5.png](./img/img6.png){: width="70%"}

- 소스 서버는 레플리카 서버가 소스 서버로부터 전달 받은 변경 이벤트를 릴레이 로그에 기록 후 응답을 보내면 그 때 트랜잭션을 완전히 커밋
- 적어도 하나의 레플리카 서버에 트랜잭션이 전송됐음을 보장
  - 전송이 보장된 것이지 실제 적용이 보장된 것은 아니다
- 서버응답을 기다리기 때문에 비동기 방식보다 트랜잭션 처리가 느려질 수 있다
- 응답이 안오면 무기한으로 기다릴 수 있기 때문에 소스 서버는 지정된 타임아웃 시간동안 응답이 없으면 비동기 복제 방식으로 전환

## 소스, 레플리카 서버 어떻게 구성?

![그림8.png](./img/img7.png)
![그림7.png](./img/img8.png)

### 싱글 레플리카 복제

- 하나의 소스서버에 하나의 레플리카 서버만 연결돼 있는 복제 형태
- 소스 서버에 문제가 생겼을 때 예비 서버 및 데이터 백업 수행을 위한 용도로 많이 사용

### 멀티 레플리카 복제

- 하나의 소스서버에 두개 이상의 레플리카 서버를 연결한 복제 형태
- 하나의 서버는 예비용으로 구성하고 다른 서버를 읽기 요청 처리를 분산하는 용도로 사용

### 체인 복제

- 하나의 소스 서버에 연결된 레플리카 서버 수가 많다면 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수 있는데 이 때 사용
- 소스 서버가 해야할 바이너리 로그 배포 역할을 새로운 서버로 넘길 수 있다

### 듀얼 소스 복제

- 두개의 서버가 서로 소스 서버이자 레플리카 서버로 구성되어 있는 형태
- 두 서버 모두 쓰기가 가능하다는 것이 특징
- 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 양쪽에서 쓰기가 발생하지만 두 서버는 동일한 데이터를 갖게 됨
- 목적에 따라 ACTIVE - PASSIVE 또는 ACTIVE- ACTIVE 형태로 사용 가능
- 싱글 레플리카와 똑같은 것이라고 생각할 수 있지만 한 서버에서 문제가 생겼을 경우 전환을 바로 가져갈 수 있다는 장점

### 멀티 소스 복제

- 하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태
- 여러 서버에 존재하는 다른 데이터를 하나의 서버로 통합하거나, 샤딩돼 있는 테이블 데이터를 하나의 테이블로 통합할 때 사용할 수 있음
